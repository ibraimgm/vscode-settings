{
	// Place your snippets for yaml here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Skeleton for golangci-lint": {
		"prefix": "golangciskel",
		"description": "Creates a skeleton .golangci-lint.yml",
		"body": [
			"# Updated for golanci-lint 1.39.0",
			"",
			"linters-settings:",
			"  errcheck:",
			"    check-type-assertions: true",
			"  misspell:",
			"    locale: US",
			"  unused:",
			"    check-exported: ${2:false}",
			"  govet:",
			"    enable-all: true",
			"  gocritic:",
			"    enabled-tags:",
			"      - diagnostic",
			"      - performance",
			"  goimports:",
			"    local-prefixes: github.com/ibraimgm/${1:projectname}",
			"",
			"linters:",
			"  fast: true",
			"  enable:",
			"    - asciicheck",
			"    - exhaustive",
			"    - funlen",
			"    - gci",
			"    - gochecknoinits",
			"    - gocognit",
			"    - gocritic",
			"    # - godot (currently, there is no way to ignore comments on private vars)",
			"    - goerr113",
			"    - goimports",
			"    - golint",
			"    - gosec",
			"    - gosimple",
			"    - govet",
			"    - misspell",
			"    - nakedret",
			"    - nolintlint",
			"    - rowserrcheck",
			"    - exportloopref",
			"    - sqlclosecheck",
			"    - staticcheck",
			"    - testpackage",
			"    - unconvert",
			"    - unparam",
			"    - unused",
			"    - whitespace",
			"",
			"issues:",
			"  exclude-rules:",
			"    # ignore some linters on test code",
			"    - path: _test\\.go",
			"      linters:",
			"        - funlen",
			"        - gocognit",
			"        - maligned",
			"",
			"    # ignore alignment issues on test files",
			"    - path: _test\\.go",
			"      text: \"fieldalignment\"",
			"      linters:",
			"        - govet",
			"",
			"    # goimports: We should care only when changing files",
			"    - text: File is not `goimports`-ed",
			"      linters:",
			"        - goimports",
			"",
			"    # errcheck: Almost all programs ignore errors on these functions and in most cases it's ok",
			"    - text: Error return value of .((os\\.)?std(out|err)\\..*|.*Close|.*Flush|os\\.Remove(All)?|.*printf?|os\\.(Un)?Setenv). is not checked",
			"      linters:",
			"        - errcheck",
			"",
			"    # staticcheck: Developers tend to write in C-style with an explicit 'break' in a 'switch', so it's ok to ignore",
			"    - text: ineffective break statement. Did you mean to break out of the outer loop",
			"      linters:",
			"        - staticcheck",
			"",
			"    # gosec: Too many issues in popular repos",
			"    - text: (Expect directory permissions to be 0750 or less|Expect file permissions to be 0600 or less)",
			"      linters:",
			"        - gosec",
			"",
			"    # gosec: Duplicated errcheck checks",
			"    - text: G104",
			"      linters:",
			"        - gosec",
			"",
			"    # gosec: Use of weak random number generator",
			"    - text: G404",
			"      linters:",
			"        - gosec",
			"",
			"    # gosec: False positive is triggered by 'src, err := ioutil.ReadFile(filename)'",
			"    - text: Potential file inclusion via variable",
			"      linters:",
			"        - gosec",
			"",
			"  exclude-use-default: false",
			"  new: ${3:false}",
		],
	},

	"Skeleton for Github Actions": {
		"prefix": "skeletongithubactions",
		"description": "Creates a skeleton GH Actions pipeline for Golang",
		"body": [
			"name: CI",
			"on: push",
			"",
			"jobs:",
			"  build-and-test:",
			"    name: build-and-test",
			"    runs-on: ubuntu-latest",
			"    steps:",
			"      - uses: actions/checkout@v2",
			"      - uses: actions/setup-go@v2",
			"        with:",
			"          go-version: '^${1:1.15}'",
			"      - run: go build",
			"      - name: Run tests",
			"        run: go test -coverprofile coverage.txt -covermode=atomic ./...",
			"      - name: Upload coverage report",
			"        uses: codecov/codecov-action@v1",
			"        with:",
			"          file: ./coverage.txt",
			"          fail_ci_if_error: true",
			"",
			"  golangci-lint:",
			"    name: golangci-lint",
			"    runs-on: ubuntu-latest",
			"    steps:",
			"      - uses: actions/checkout@v2",
			"      - uses: golangci/golangci-lint-action@v2",
			"        with:",
			"          version: v${2:1.34}",
			"",
		]
	},

	"Skeleton for travisci": {
		"prefix": "skeletontravis",
		"description": "Creates a skeleton .travis.yml",
		"body": [
			"language: go",
			"",
			"go:",
			"  - ${1:1.11.x}",
			"",
			"notifications:",
			"  email: false",
			"",
			"env:",
			"  - GO111MODULE=on",
			"",
			"script: go test -v -coverprofile coverage.txt -covermode=atomic ./...",
			"",
			"after_success:",
			"  - bash <(curl -s https://codecov.io/bash)",
		]
	},
	"Skeleton for codecov.yml": {
		"prefix": "skeletoncodecov",
		"description": "Creates a skeleton .codecov.yml",
		"body": [
			"coverage:",
			"  status:",
			"    project:",
			"      default:",
			"        #target: 80",
			"        #threshold: 5",
			"        informational: true",
			"    patch:",
			"      default:",
			"        informational: true",
		]
	},
	"Kubernetes - ConfigMap": {
		"prefix": "kubecfgmap",
		"description": "Creates a simple configmap",
		"body": [
			"apiVersion: v1",
			"kind: ConfigMap",
			"metadata:",
			"  name: ${1:cfgmapname}",
			"data:",
			"  color: purple",
			"  how: fairlyNice",
			"  textmode: \"true\"",
		],
	},
	"Kubernetes - Deployment": {
		"prefix": "kubedeploy",
		"description": "Creates a k8s deployment",
		"body": [
			"apiVersion: apps/v1",
			"kind: Deployment",
			"metadata:",
			"  name: ${1:servicename}",
			"spec:",
			"  replicas: 1",
			"  selector:",
			"    matchLabels:",
			"      app: $1",
			"  template:",
			"    metadata:",
			"      labels:",
			"        app: $1",
			"    spec:",
			"      # ----",
			"      # Docker Private registry example:",
			"      # kubectl create secret docker-registry regcred --docker-server=\"https://index.docker.io/v2/\" --docker-username=(user) --docker-password=\"(pwd)\" --docker-email=\"(mail)\"",
			"      #imagePullSecrets:",
			"      #  - name: regcred",
			"      # ----",
			"      # Mounting a configmap as a volume (see below, volumeMounts)",
			"      # ex: kubectl create configmap ca-certificate --from-file=ca-certificate.crt",
			"      # ----",
			"      volumes:",
      "        - name: ca-certificate-volume",
      "          configMap:",
      "            name: ca-certificate",
			"      containers:",
			"        - name: $1",
			"          image: ${2:imageuser}/$1",
			"          # custom command",
			"          # command: [\"tail\", \"-f\", \"/dev/null\"]",
			"          imagePullPolicy: IfNotPresent",
			"          # Liveness probe sample. Consider if you can also afford a readiness probe",
			"          #livenessProbe:",
      "          #  httpGet:",
      "          #    path: /mail/liveness",
      "          #    port: 3000",
      "          #  initialDelaySeconds: 10",
      "          #  periodSeconds: 30",
			"          #not strictly needed:",
			"          #ports:",
			"          #  - containerPort: 8080 # port that the container exposes",
			"#         volumeMounts:",
			"#         - name: ca-certificate-volume",
			"#           mountPath: /some/absolute/dir",
			"#          env:",
			"#            - name: ENV_VAR",
			"#              value: \"foo\"",
      "#            - name: ENV_FROM_SECRET",
      "#              valueFrom:",
      "#                secretKeyRef:",
      "#                  name: some-secret",
      "#                   key: KEY_INSIDE_SECRET",
			"#            - name: ENV_FROM_CONFIGMAP",
      "#              valueFrom:",
      "#                configMapKeyRef:",
      "#                  name: some-configmap",
      "#                   key: KEY_INSIDE_CONFIGMAP",
			"          resources:",
			"              limits:",
			"                cpu: \"250m\"",
			"                memory: \"1G\"",
		]
	},
	"Kubernetes - ClusterIP Service": {
		"prefix": "kubeclusterip",
		"description": "Creates a k8s ClusterIP service",
		"body":[
			"apiVersion: v1",
			"kind: Service",
			"metadata:",
			"  name: ${1:servicename}",
			"spec:",
			"  selector:",
			"    app: $1",
			"  type: ClusterIP",
			"  ports:",
			"    - name: $1",
			"      protocol: TCP",
			"      port: ${2:8080} # acessible inside cluster",
			"      targetPort: $2 # forward to this container port",
		]
	},
	"Kubernetes - NodeIP Service": {
		"prefix": "kubenoderip",
		"description": "Creates a k8s NodeIP service",
		"body":[
			"apiVersion: v1",
			"kind: Service",
			"metadata:",
			"  name: ${1:servicename}",
			"spec:",
			"  selector:",
			"    app: $1",
			"  type: NodePort",
			"  ports:",
			"    - name: $1",
			"      protocol: TCP",
			"      port: ${2:8080}",
			"      targetPort: $2",
		]
	},
	"Kubernetes - NGINX Ingress Service": {
		"prefix": "kubenginx",
		"description": "Creates a k8s Ingress resource (NGINX)",
		"body": [
			"apiVersion: networking.k8s.io/v1",
			"kind: Ingress",
			"metadata:",
			"  name: ${1:ingressname}",
			"  annotations:",
			"    kubernetes.io/ingress.class: \"nginx\"",
			"    # cert-manager.io/cluster-issuer: \"letsencrypt-prod\"",
			"    # nginx.ingress.kubernetes.io/rewrite-target: /\\$1",
			"    # nginx.ingress.kubernetes.io/use-regex: 'true'",
			"spec:",
			"  tls:",
			"    - hosts:",
			"      - ${2:myhost.com}",
			"        secretName: my-tls",
			"  rules:",
			"    - host: $2",
			"      http:",
			"        paths:",
			"          - pathType: Prefix",
			"            path: \"/\"",
			"            backend:",
			"              service:",
			"                name: someservice",
			"                port:",
			"                  number: 8080",
		]
	},
	"Kubernetes - Secret": {
		"prefix": "kubesecret",
		"description": "Creates a sample kubernetes secret",
		"body": [
			"apiVersion: v1",
			"kind: Secret",
			"metadata:",
			"  name: ${1:name}-secret",
			"type: Opaque",
			"stringData:",
			"  KEY_1: plainvalue1",
			"  KEY_2: plainvalue2",
			"  KEY_3: plainvalue3",
		]
	},
	"Kubernetes - Pod": {
		"prefix": "kubepod",
		"description": "Simple utility pod",
		"body": [
			"apiVersion: v1",
			"kind: Pod",
			"metadata:",
			"  name: ${1:utility-pod}",
			"  labels:",
			"    app: $1",
			"spec:",
			"  containers:",
			"  - name: $1",
			"    image: ${2:imagename}",
			"    command: [\"tail\", \"-f\", \"/dev/null\"]",
			"    # args: [\"HOSTNAME\", \"KUBERNETES_PORT\"]",
			"  restartPolicy: OnFailure"
		]
	},
	"Kubernetes - CertManager (LetsEncrypt)": {
    "prefix": "kubecertissuer",
		"description": "ClusterIssuer demo",
		"body": [
			"apiVersion: cert-manager.io/v1alpha2",
			"kind: ClusterIssuer",
			"metadata:",
			"  name: letsencrypt-staging",
			"  namespace: cert-manager",
			"spec:",
			"  acme:",
			"    # for production, use: server: https://acme-v02.api.letsencrypt.org/directory",
			"    server: https://acme-staging-v02.api.letsencrypt.org/directory",
			"    email: projetabrasil@projetabrasil.net.br",
			"    privateKeySecretRef:",
			"      # don't forget to reference this name on the ingress annotation",
			"      name: letsencrypt-staging",
			"    solvers:",
			"    - http01:",
			"        ingress:",
			"          class: nginx"
		]
	},
	"Prometheus - Basic config": {
		"prefix": "promconfig",
		"description":"Initial prometheus config",
		"body": [
			"# my global config",
			"global:",
			"  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.",
			"  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.",
			"  # scrape_timeout is set to the global default (10s).",
			"",
			"# Alertmanager configuration",
			"alerting:",
			"  alertmanagers:",
			"    - static_configs:",
			"        - targets:",
			"          - localhost:9093",
			"",
			"# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.",
			"rule_files:",
			"  - \"myrules.yml\"",
			"",
			"# A scrape configuration containing exactly one endpoint to scrape:",
			"# Here it's Prometheus itself.",
			"scrape_configs:",
			"  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.",
			"  - job_name: \"prometheus\"",
			"",
			"    # metrics_path defaults to '/metrics'",
			"    # scheme defaults to 'http'.",
			"",
			"    static_configs:",
			"      - targets: [\"localhost:9090\"]",
			"",
			"  - job_name: \"node_exporter\"",
			"    static_configs:",
			"      - targets: [\"localhost:9100\"]",
			"",
			"  - job_name: \"blockmaker\"",
			"    static_configs:",
			"      - targets: [\"localhost:9200\"]"
		]
	},
	"Prometheus - Rules file": {
		"prefix": "promrules",
		"description": "A sample rules files, with records and alerts",
		"body": [
			"# for interesting sample rules, check:",
			"# https://github.com/samber/awesome-prometheus-alerts",
			"",
			"groups:",
			"  - name: my-rules",
			"    rules:",
			"    - record: job:node_cpu_seconds:avg_idle",
			"      expr: avg without(cpu)(rate(node_cpu_seconds_total{mode=\"idle\"}[5m]))",
			"",
			"    - alert: NodeExporterDown",
			"      expr: up{job=\"node_exporter\"} == 0",
			"      for: 1m # wait for 1m instead of firing immediately",
			"",
			"    - record: job:app_response_latency_seconds:rate1m",
			"      expr: rate(app_response_latency_seconds_sum[1m]) / rate(app_response_latency_seconds_count[1m])",
			"",
			"    - alert: AppLatencyAbove5sec",
			"      expr: job:app_response_latency_seconds:rate1m >= 5",
			"      for: 2m",
			"      labels: #labels can be used to route alerts on alertmanager",
			"        severity: critical # the key/values here are 100% arbitrary",
			"      annotations: # annotations are additional data to be send with the alerts.",
			"        summary: \"Python app latency is over 5 seconds.\" # The key/values are arbitrary, and support templating",
			"        description: \"App latency of instance {{ $labels.instance }} of job {{ $labels.job }} is {{ $value }} seconds for more than 5 minutes.\"",
			"        app_link: \"http://localhost:8000/\"",
			"",
			"    - alert: AppLatencyAbove2sec",
			"      expr: 2 < job:app_response_latency_seconds:rate1m < 5",
			"      for: 2m",
			"      labels:",
			"        severity: warning",
		]
	},
	"Prometheus - AlertManager": {
		"prefix": "promalertmanager",
		"description": "Sample alert manager routing tree configuration",
		"body": [
			"# This is a sample alertmanager.yml, to be used with prometheus alertmanager",
			"",
			"# to test your routing tree, try:",
			"# https://prometheus.io/webtools/alerting/routing-tree-editor/",
			"",
			"# global is only necessary if you want to avoid excessive repetition",
			"# on some configurations",
			"global:",
			"  smtp_from: \"example@gmail.com\"",
			"  smtp_smarthost: smtp.gmail.com:587",
			"  smtp_auth_username: \"example@gmail.com\"",
			"  smtp_auth_identity: \"example@gmail.com\"",
			"  smtp_auth_password: \"fqkvkumorgaqgkat\"",
			"",
			"route:",
			"  # fallback receiver",
			"  receiver: admin",
			"  # all the group/repeat params are optional, and can be",
			"  # added at the root (like this) or in specific subroutes",
			"  group_wait: 30s # initial delay before sending alerts of a given group",
			"  group_interval: 5m # time to wait before sending a new alert into a group that wa already sent",
			"  repeat_interval: 1m # time to wait before re-sending an alert",
			"  routes:",
			"    # Star Solutions.",
			"  - match_re: # use match_re to match \"complex\" values. The app_type is a arbitrary label created in the alert config",
			"      app_type: (linux|windows)",
			"    # fallback receiver ",
			"    receiver: ss-admin",
			"    # group_by: [severity] # this is one or more labels defined in the alerts",
			"    routes:",
			"    # Linux team",
			"    - match: # use \"match\" to match a value exactly",
			"        app_type: linux",
			"      # fallback receiver",
			"      receiver: linux-teamlead",
			"      routes:",
			"      - match:",
			"          severity: critical",
			"        receiver: delivery-manager",
			"      - match:",
			"          severity: warning",
			"        receiver: linux-teamlead",
			"",
			"    # Windows team",
			"    - match:",
			"        app_type: windows",
			"      # group_by: [severity]",
			"      # fallback receiver",
			"      receiver: windows-teamlead",
			"      routes:",
			"      - match:",
			"          severity: critical",
			"        receiver: delivery-manager",
			"      - match:",
			"          severity: warning",
			"        receiver: windows-teamlead",
			"",
			"    # PEC Technologies.",
			"  - match_re:",
			"      app_type: (python|go)",
			"    # fallback receiver ",
			"    receiver: pec-admin",
			"    routes:",
			"    # Python team",
			"    - match:",
			"        app_type: python",
			"      # fallback receiver",
			"      receiver: python-team-admin",
			"      routes:",
			"      - match:",
			"          severity: critical",
			"        receiver: python-team-manager",
			"      - match:",
			"          severity: warning",
			"        receiver: python-team-lead",
			"",
			"    # Go team",
			"    - match:",
			"        app_type: go",
			"      # fallback receiver",
			"      receiver: go-team-admin",
			"      routes:",
			"      - match:",
			"          severity: critical",
			"        receiver: go-team-manager",
			"      - match:",
			"          severity: warning",
			"        receiver: go-team-lead",
			"",
			"# this inhibit rule makes that once a severity=critical alert is",
			"# triggered, the severity=warning alerts will be inhibited, as long",
			"# as the app_type and category are equal. It is useful to avoid sending",
			"# useless alerts.",
			"#",
			"# Note that all the values here are from labes specified in the alert creation.",
			"inhibit_rules:",
			"- source_match:",
			"    severity: \"critical\"",
			"  target_match:",
			"    severity: \"warning\"",
			"  equal: [\"app_type\", \"category\"]",
			"",
			"receivers:",
			"- name: admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: ss-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: linux-team-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: linux-team-lead",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: linux-team-manager",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: windows-team-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: windows-team-lead",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: windows-team-manager",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: pec-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: python-team-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: python-team-lead",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: python-team-manager",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: go-team-admin",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: go-team-lead",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
			"",
			"- name: go-team-manager",
			"  email_configs:",
			"  - to: \"example@gmail.com\"",
		]
	},
	"Skaffold - Template": {
		"prefix": "skeletonskaffold",
		"description": "A simple skaffold example",
		"body": [
			"apiVersion: skaffold/v2alpha3",
			"kind: Config",
			"deploy:",
			"  kubectl:",
			"    manifests:",
			"      - ${1:./infra/k8s/*}",
			"build:",
			"  local:",
			"    push: false",
			"  artifacts:",
			"    - image: ${2:imguser}/${3:project}",
			"      context: $3",
			"      docker:",
			"        dockerfile: Dockerfile",
			"      sync:",
			"        manual:",
			"          - src: 'src/**/*.js'",
			"            dest: .",
		]
	},
	"Clang format file": {
		"prefix":"c_clangformat",
		"description": "Bare-bones clang-format file",
		"body": [
			"BasedOnStyle: LLVM",
		]
	}
}
